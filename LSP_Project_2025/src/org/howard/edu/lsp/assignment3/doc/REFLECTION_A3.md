In Assignment 2, I did not at all focus on object-oriented programming when implementing my design. My ETL Pipeline contained a single main method that handled all of the different aspects needed to complete the assignment. That meant reading the CSV file, accessing and transforming the data, and writing the output to another CSV file. Product details such as the ID, name, price, and category were stored in variables within the loop, and the discount transformation and category changes occurred inside that same loop as well. I did make a separate file to originally create and write to the products.csv file, but overall my approach was functional and procedural. While it worked, it was not an optimal solution because it would have been difficult to expand on in the future, and even small changes risked breaking the main logic. The design lacked flexibility and clear separation of responsibilities.


With Assignment 3 and the help of generative AI I worked on making my code more object-oriented. For this version, I focused on creating new Java files with specialized functions instead of having ETLPipeline main perform everything. I created a Product class to represent each product, gathering its associated data such as ID, name, price, category, and price range along with certain behaviors. Initially, I placed a transform method directly inside Product to handle all transformations, but with feedback I realized it would be more efficient and maintainable to move that logic into a separate ProductTransform class. This change followed the single responsibility principle and made the code more modular. The updated ETLPipeline in Assignment 3 is now responsible only for coordinating the process: it reads the CSV using CSVReader, applies transformations with ProductTransform, and writes the results with CSVWriter. This separation of concerns makes the design more organized, readable, and easier to update in the future.


I utilized several object-oriented concepts in Assignment 3 to improve my design. The Product class represents an object, encapsulating both data and behaviors related to a single product. Encapsulation is enforced through private fields and controlled access via getters and setters. The ProductTransform class demonstrates abstraction by hiding the detailed transformation rules behind a clear transform(Product p) method. Although I did not create subclasses, the design leaves room for inheritance if I later want to define specialized product types, such as DigitalProduct or DiscountedProduct. Similarly, the design supports polymorphism, since different transformer classes could share a common interface and be swapped into the pipeline without altering its core structure. These changes show how Assignment 3 is more extensible and better aligned with object-oriented principles than Assignment 2.


To ensure that Assignment 3 worked the same as Assignment 2, I tested the code in multiple ways. I ran the program on the original products.csv file and confirmed that the transformed CSV output matched the results from Assignment 2. I also tested edge cases, such as deleting the input file to confirm that the program produced the correct error message. Additionally, I modified rows in the input CSV to verify that the read, transform, and write steps tracked counts of rows read, transformed, and skipped correctly. Finally, I manually inspected the inputs and outputs to ensure transformations like uppercasing names, applying discounts, updating categories, and assigning price ranges were handled correctly. I compared these results with the original output from Assignment 2, and everything aligned as expected.


Overall, using generative AI for this assignment helped me not only complete the task but also learn how object-oriented design can be applied to improve the structure of my code. It was especially useful to have AI (in my case ChatGPT) explain concepts such as abstraction and encapsulation, suggest how to split logic into classes, and walk through various  ways to improve my code. 
